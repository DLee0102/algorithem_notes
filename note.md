# 算法笔记
## 一些小细节
- char* 不能和cin搭配
- C++ 1s 之内能算十的七次方到十的八次方左右
- 和字符相关的输入用scanf时最好读取字符串而不是读取字符，因为读取字符串时会跳过空格、换行符和制表符，而读取字符时不会跳过空格、换行符和制表符
- 关于memset：
  - https://blog.csdn.net/Supreme7/article/details/115431235
  - 该函数是按字节赋值
## 算法
1. 双指针算法：双指针算法优化的关键就是找单调性。
2. 位运算的常用操作：
   1. n的二进制表示中，第k位是几。
      1. 先把第k位移到最后一位：n >> k；
      2. 看个位是几：n & 1；
      3. 总结：(n >> k) & 1s；
   2. lowbit(x): 返回x的最后一位1，以及之后的所有零。 x & -x；
      1. 补码是怎么来的：在数学中：-x + x = 0，即-x = 0 - x；则在计算机中，-x = 0000 - x，不够减要借一位，所以是 -x = 10000 - x，即-x = ~x + 1；
3. 离散化（保序）：
   1. 可能有重复元素，需要去重；
   2. 如何算出数组中每一个值离散化后的值是多少；
4. 链表
   1. new一个struct非常慢，所以可以用数组模拟链表；
   2. 分类
      1. 单链表：用来做邻接表（存储图和树）；head->o->o->...->o->NULL；
      2. 双链表：优化某些问题
      3. 插入和删除都是操作的k后面一个节点
5. 单调栈
6. 单调队列（滑动窗口问题，可将时间复杂度从o（nk）降到o（n））
   1. 和单调栈的核心思想相同，都是删除冗余元素
   2. 每次移动队头和队尾的指针时要判断队列是否为空
7. 关于STL容器：通常编译时编译器会开O2优化或O3优化，这时STL和数组模拟的效果相差无几，但在比赛时比赛举办方会关掉这些优化，这时STL的效率会很低，所以在比赛时尽量用数组模拟。
8. kmp
9. Trial树
   1.  Trial树的层高是固定的，等于for循环的次数
   2. 可以存储所有二进制信息
10. 并查集
    1.  路径压缩
    2.  按秩合并
11. 堆
    1.  初始化堆是从原始数组的一半处开始向前初始化，因为此处的节点满足其孩子节点是堆，且是最后一个需要建堆的节点
12. 哈希表
    1.  存储结构
        1.  开放寻址法
        2.  拉链法
    2.  字符串哈希方式
        1.  字符串前缀哈希法：
            1.  不能映射成0
            2.  p = 131 或 p = 13331 以及Q = 2^64时，冲突概率很小，约为0.01%
    3.  添加+查找+删除（标记法删除 ）
    4.  用来mod的这个数一般要取成质数，而且要离2的整次幂远一些，这样可以减少冲突  
    5.  开放寻址法的存储空间一般情况下要开到题目要求范围的2-3倍，这样冲突的概率较小
    6.  C++中取模的操作要注意，如果是负数，结果也是负数，所以要加上mod，保证结果是正数
13. DFS
    1.  最重要的是顺序，基础逻辑结构是一个树，利用树的分支和递归结构来思考问题
    2.  每次递归路径执行完成记得恢复现场
    3.  在n皇后问题中，斜对角线的索引方法可以用笛卡尔坐标系下直线方程的截距来理解
14. BFS
    1.  能够搜到最短路
    2.  最短路问题包含DP问题，DP问题是一个没有环存在的最短路问题
    3.  边权都是1的时候，才可以用BFS求最短路
    4.  BFS问题的模板：
        1.  新建一个队列（该队列是广度优先遍历的关键）
        2.  每次从队头取出一个元素，更新队尾
        3.  直到队列为空
15. 八字码
    1.  有一种可以把一维数组下标转换为二维数组下标的方法（整除得[x][]，取余得[][y]）
16. 树的重心
    1.  深度优先遍历可以自然形成一个树状的数据结构
17. 拓扑序列
    1.  有向图才有拓扑序列
    2.  有向无环图一定存在拓扑序列
    3.  用BFS，拓扑图的顺序遍历就是一个最简单的图的广度优先遍历模版
18. Dijsktra
    1.  稠密图用邻接矩阵，稀疏图用邻接表
    2.  堆优化的Dijsktra算法
        1.  堆优化要用稀疏表，朴素的Dijsktra算法用稠密矩阵
        2.  C++优先队列如果对一个pair进行处理的话会根据first的值进行排序
        3.  堆优化的算法中堆中存储的数据含有冗余数据
19. Bellman-Ford
    1.  三角不等式
    2.  松弛操作
    3.  处理有负权边，有负权回路（一圈的长度小于0 ）的话最短路不一定存在
    4.  最外层迭代的含义是从第一个点通过不超过k条边到达的点的最短路径
    5.  该算法可以用来寻找负环